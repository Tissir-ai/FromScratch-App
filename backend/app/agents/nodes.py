from __future__ import annotations

from typing import cast
import json
from uuid import UUID

from app.agents.state import BlueprintState
from app.agents.requirements_agent import generate_requirements
from app.agents.diagram_agent import generate_diagrams
from app.agents.planner_agent import generate_plan_json
from app.agents.export_agent import generate_export_json
from app.agents.metadata_agent import generate_project_metadata
# from app.agents.export_agent import export_markdown  # COMMENTED: No longer using MinIO
# from app.agents.tools.db_tools import persist_artifact  # DEPRECATED: MongoDB async
from app.core.events import publish
from app.repositories import runs_repo  # MongoDB version


# ------------------------------------------------------------
# Helper: init state (utilise-le dans run_blueprint_pipeline)
# ------------------------------------------------------------
def make_initial_state(project_id: str, run_id: UUID, idea: str) -> BlueprintState:
    state: BlueprintState = {
        "project_id": project_id,
        "run_id": run_id,
        "idea": idea,

        # Project metadata (will be generated by metadata agent)
        "project_name": None,
        "project_description": None,

        # init
        "problem_definition": None,
        "functional_requirements": None,
        "non_functional_requirements": None,
        "architecture": None,
        "uml_sequence": None,
        "sprint_planning": None,
        
        # Contenu texte pour frontend (pas de MinIO)
        "requirements_content": None,
        "diagrams_content": None,
        "diagrams_json_content": None,
        "planner_json_content": None,
        "export_content": None,
        "export_json_content": None,
        
        # MinIO URIs (COMMENTED - not used anymore)
        # "requirements_uri": None,
        # "diagrams_uri": None,
        # "diagrams_json_uri": None,
        # "planner_uri": None,
        # "plan_uri": None,
        # "result_uri": None,
        
        "blueprint_markdown": None,
    }
    return state


# ------------------------------------------------------------
# Node 0: Metadata (generates project name and description)
# ------------------------------------------------------------
async def node_metadata(state: BlueprintState) -> BlueprintState:
    """
    First node: analyzes the idea and generates project metadata.
    Updates the project immediately with the generated name/description.
    """
    idea = state["idea"]
    run_id = state["run_id"]
    project_id = state["project_id"]

    publish(f"run:{run_id}", "Running: MetadataAgent")

    try:
        # 1) LLM - Generate project metadata
        metadata = await generate_project_metadata(idea)
        
        # 2) Update state
        state["project_name"] = metadata["name"]
        state["project_description"] = metadata["description"]

        # 3) Save to MongoDB run state
        state_json = {
            "project_name": state.get("project_name"),
            "project_description": state.get("project_description"),
        }
        await runs_repo.update_run_state(run_id, state_json)

        # 4) Update the project document immediately
        from app.services.project_service import update_project_metadata
        await update_project_metadata(
            project_id=project_id,
            name=metadata["name"],
            description=metadata["description"]
        )

        # 5) Publish notification
        publish(f"run:{run_id}", f"PROJECT_NAME:{metadata['name']}")
        
        print(f"[METADATA_NODE] Generated: name='{metadata['name']}', desc='{metadata['description']}'")
        
    except Exception as e:
        print(f"[METADATA_NODE] Error: {e}. Using fallback.")
        # Fallback: use idea as name/description
        fallback_name = idea[:60].strip() if len(idea) <= 60 else idea[:57].strip() + "..."
        state["project_name"] = fallback_name
        state["project_description"] = idea[:200].strip() if len(idea) <= 200 else idea[:197].strip() + "..."

    return state


# ------------------------------------------------------------
# Node 1: Requirements
# ------------------------------------------------------------
async def node_requirements(state: BlueprintState) -> BlueprintState:
    idea = state["idea"]
    run_id = state["run_id"]
    project_id = state["project_id"]

    publish(f"run:{run_id}", "Running: RequirementsAgent")

    # 1) LLM - GÃ©nÃ¨re le contenu requirements
    requirements_md = await generate_requirements(idea)

    # 2) Export (MinIO/S3) - COMMENTED: stockage direct dans state
    # uri = await export_markdown(
    #     project_id=project_id,
    #     content=requirements_md,
    # )

    # 3) Persist DB - COMMENTED: optionnel, on peut garder juste en mÃ©moire
    # persist_artifact(
    #     session=session,
    #     project_id=project_id,
    #     kind="requirements",
    #     content=requirements_md,
    #     storage_uri=None,
    # )

    # 4) Update state - Stockage direct du texte
    state["problem_definition"] = requirements_md
    state["functional_requirements"] = requirements_md
    state["requirements_content"] = requirements_md  # ðŸ†• Pour le frontend

    # 5) Sauvegarder le state complet en JSON dans la DB (MongoDB async)
    state_json = {
        "requirements_content": state.get("requirements_content"),
        "diagrams_content": state.get("diagrams_content"),
        "diagrams_json_content": state.get("diagrams_json_content"),
        "planner_json_content": state.get("planner_json_content"),
        "export_content": state.get("export_content"),
        "export_json_content": state.get("export_json_content"),
        "blueprint_markdown": state.get("blueprint_markdown"),
    }
    await runs_repo.update_run_state(run_id, state_json)

    return state


# ------------------------------------------------------------
# Node 2: Diagrams
# ------------------------------------------------------------
async def node_diagrams(state: BlueprintState) -> BlueprintState:
    idea = state["idea"]
    run_id = state["run_id"]
    project_id = state["project_id"]

    publish(f"run:{run_id}", "Running: DiagramAgent")

    # 1) LLM - GÃ©nÃ¨re les diagrammes JSON React Flow
    diagrams_json_str = await generate_diagrams(idea)

    # 2a) Export JSON pour le frontend - COMMENTED: stockage direct
    # from app.agents.tools.storage_tools import put_json
    # json_uri = await put_json(
    #     project_id=project_id,
    #     content=diagrams_json_str,
    #     filename="diagrams.json",
    # )

    # 2b) Markdown pour la doc (description textuelle)
    diagrams_md = f"""# System Diagrams

React Flow diagrams are available in JSON format.
JSON contains 4 diagram types: Class, Sequence, Activity, Use Case.

These diagrams can be rendered directly in the frontend using React Flow.

## Available Diagrams:
- Class Diagram: Object-oriented structure
- Sequence Diagram: Interaction flow
- Activity Diagram: Process flow
- Use Case Diagram: User interactions

"""
    
    # 2c) Export Markdown - COMMENTED: stockage direct
    # uri = await export_markdown(
    #     project_id=project_id,
    #     content=diagrams_md,
    # )

    # 3) Persist DB - COMMENTED: optionnel
    # persist_artifact(
    #     session=session,
    #     project_id=project_id,
    #     kind="diagrams",
    #     content=diagrams_md,
    #     storage_uri=None,
    # )
    # persist_artifact(
    #     session=session,
    #     project_id=project_id,
    #     kind="diagrams_json",
    #     content=diagrams_json_str,
    #     storage_uri=None,
    # )

    # 4) Update state - Stockage direct du texte
    state["architecture"] = diagrams_md
    state["uml_sequence"] = diagrams_md
    state["diagrams_content"] = diagrams_md  # ðŸ†• Markdown pour le frontend
    state["diagrams_json_content"] = diagrams_json_str  # ðŸ†• JSON React Flow

    # 5) Sauvegarder le state complet en JSON dans la DB (MongoDB async)
    state_json = {
        "requirements_content": state.get("requirements_content"),
        "diagrams_content": state.get("diagrams_content"),
        "diagrams_json_content": state.get("diagrams_json_content"),
        "planner_json_content": state.get("planner_json_content"),
        "export_content": state.get("export_content"),
        "export_json_content": state.get("export_json_content"),
        "blueprint_markdown": state.get("blueprint_markdown"),
    }
    await runs_repo.update_run_state(run_id, state_json)

    return state


# ------------------------------------------------------------
# Node 3: Planner
# ------------------------------------------------------------
async def node_planner(state: BlueprintState) -> BlueprintState:
    idea = state["idea"]
    run_id = state["run_id"]
    project_id = state["project_id"]

    publish(f"run:{run_id}", "Running: PlannerAgent")

    # 1) LLM - GÃ©nÃ¨re le plan structurÃ© (JSON uniquement - pas de markdown pour Ã©conomiser tokens)
    plan_json_str = await generate_plan_json(idea)

    # 2) Clean JSON if wrapped in markdown code blocks
    cleaned_json = plan_json_str.strip()
    if cleaned_json.startswith("```"):
        lines = cleaned_json.split("\n")
        if lines[0].startswith("```"):
            lines = lines[1:]
        if lines and lines[-1].strip() == "```":
            lines = lines[:-1]
        cleaned_json = "\n".join(lines).strip()

    # 3) Update state - Stockage JSON uniquement (optimisation tokens)
    state["planner_json_content"] = cleaned_json

    # 4) Sauvegarder le state complet en JSON dans la DB (MongoDB async)
    state_json = {
        "requirements_content": state.get("requirements_content"),
        "diagrams_content": state.get("diagrams_content"),
        "diagrams_json_content": state.get("diagrams_json_content"),
        "planner_json_content": state.get("planner_json_content"),
        "export_content": state.get("export_content"),
        "export_json_content": state.get("export_json_content"),
        "blueprint_markdown": state.get("blueprint_markdown"),
    }
    await runs_repo.update_run_state(run_id, state_json)

    return state


# ------------------------------------------------------------
# Node 4: Export / Result URI
# ------------------------------------------------------------
async def node_export(state: BlueprintState) -> BlueprintState:
    run_id = state["run_id"]
    idea = state["idea"]

    publish(f"run:{run_id}", "Running: ExportAgent")

    # 1) Assemble markdown final pour la documentation complÃ¨te
    state["blueprint_markdown"] = "\n\n".join(
        filter(
            None,
            [
                state.get("problem_definition"),
                state.get("architecture"),
                state.get("sprint_planning"),
            ],
        )
    )
    
    # 2) Stocke aussi le contenu final dans export_content
    state["export_content"] = state["blueprint_markdown"]

    # 3) GÃ©nÃ¨re le JSON structurÃ© pour l'export (document + github_export)
    export_json_str = await generate_export_json(
        idea=idea,
        requirements=state.get("requirements_content") or "",
        diagrams_json=state.get("diagrams_json_content") or "",
        planner_json=state.get("planner_json_content") or "",
    )

    # 4) Clean JSON if wrapped in markdown code blocks
    cleaned_json = export_json_str.strip()
    if cleaned_json.startswith("```"):
        lines = cleaned_json.split("\n")
        if lines[0].startswith("```"):
            lines = lines[1:]
        if lines and lines[-1].strip() == "```":
            lines = lines[:-1]
        cleaned_json = "\n".join(lines).strip()

    state["export_json_content"] = cleaned_json

    # 5) Sauvegarder le state final complet en JSON dans la DB (MongoDB async)
    state_json = {
        "requirements_content": state.get("requirements_content"),
        "diagrams_content": state.get("diagrams_content"),
        "diagrams_json_content": state.get("diagrams_json_content"),
        "planner_json_content": state.get("planner_json_content"),
        "export_content": state.get("export_content"),
        "export_json_content": state.get("export_json_content"),
        "blueprint_markdown": state.get("blueprint_markdown"),
    }
    await runs_repo.update_run_state(run_id, state_json)

    publish(f"run:{run_id}", "DONE: All content stored in state")

    return state


# ------------------------------------------------------------
# Node 5: Persist to Collections
# ------------------------------------------------------------
async def node_persist_to_collections(state: BlueprintState) -> BlueprintState:
    """
    Final node: Persists the generated data from state to the appropriate
    domain collections (diagrams, requirements, project).
    Uses existing service functions.
    """
    from app.services import diagram_service, requirement_service, project_service
    from app.domain.diagram import DiagramStructure
    from app.domain.requirement import RequirementStructure
    from datetime import datetime
    
    run_id = state["run_id"]
    project_id = state["project_id"]

    publish(f"run:{run_id}", "Running: PersistToCollections")
    print(f"[PERSIST_NODE] Starting persist for project_id={project_id}")

    try:
        # -----------------------------------------------------
        # 1) Save Diagrams from diagrams_json_content
        # -----------------------------------------------------
        diagrams_json_str = state.get("diagrams_json_content")
        if diagrams_json_str:
            try:
                diagrams_data = json.loads(diagrams_json_str)
                diagrams_saved = 0
                
                # diagrams_data has keys: class, sequence, activity, usecase
                for diagram_type, diagram_content in diagrams_data.items():
                    if isinstance(diagram_content, dict) and "nodes" in diagram_content:
                        diagram_struct = DiagramStructure(
                            title=diagram_content.get("title", f"{diagram_type.capitalize()} Diagram"),
                            type=diagram_content.get("type", diagram_type),
                            nodes=diagram_content.get("nodes", []),
                            edges=diagram_content.get("edges", []),
                            created_at=datetime.utcnow(),
                            updated_at=datetime.utcnow(),
                        )
                        await diagram_service.create(project_id, diagram_struct)
                        diagrams_saved += 1
                
                print(f"[PERSIST_NODE] Saved {diagrams_saved} diagrams")
            except json.JSONDecodeError as e:
                print(f"[PERSIST_NODE] Failed to parse diagrams JSON: {e}")
            except Exception as e:
                print(f"[PERSIST_NODE] Error saving diagrams: {e}")

        # -----------------------------------------------------
        # 2) Save Requirements from requirements_content
        # -----------------------------------------------------
        requirements_md = state.get("requirements_content")
        if requirements_md:
            try:
                # Save the full requirements document as a single requirement
                requirement_struct = RequirementStructure(
                    title="Project Requirements Document",
                    category="Full Document",
                    description="Auto-generated requirements from blueprint agent",
                    content=requirements_md,
                    created_at=datetime.utcnow(),
                    updated_at=datetime.utcnow(),
                )
                await requirement_service.create(project_id, requirement_struct)
                print(f"[PERSIST_NODE] Saved requirements document")
            except Exception as e:
                print(f"[PERSIST_NODE] Error saving requirements: {e}")

        # -----------------------------------------------------
        # 3) Update Project with full_description (blueprint)
        # -----------------------------------------------------
        blueprint_md = state.get("blueprint_markdown")
        if blueprint_md:
            try:
                await project_service.update(project_id, {
                    "full_description": blueprint_md,
                    "updated_at": datetime.utcnow(),
                })
                print(f"[PERSIST_NODE] Updated project full_description")
            except Exception as e:
                print(f"[PERSIST_NODE] Error updating project: {e}")

        # -----------------------------------------------------
        # 4) Save Sprint Plan as a requirement document
        # -----------------------------------------------------
        planner_md = state.get("planner_content")
        if planner_md:
            try:
                plan_struct = RequirementStructure(
                    title="Project Execution Plan",
                    category="Sprint Planning",
                    description="Auto-generated sprint plan from blueprint agent",
                    content=planner_md,
                    created_at=datetime.utcnow(),
                    updated_at=datetime.utcnow(),
                )
                await requirement_service.create(project_id, plan_struct)
                print(f"[PERSIST_NODE] Saved sprint plan document")
            except Exception as e:
                print(f"[PERSIST_NODE] Error saving sprint plan: {e}")

        publish(f"run:{run_id}", "PERSIST: Data saved to collections")
        print(f"[PERSIST_NODE] Completed successfully")

    except Exception as e:
        print(f"[PERSIST_NODE] Critical error: {e}")
        publish(f"run:{run_id}", f"PERSIST_ERROR: {str(e)}")

    return state
