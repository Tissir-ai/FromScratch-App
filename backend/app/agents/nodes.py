from __future__ import annotations

from typing import cast
import json
from uuid import UUID

from app.agents.state import BlueprintState
from app.agents.requirements_agent import generate_requirements
from app.agents.diagram_agent import generate_diagrams
from app.agents.planner_agent import generate_plan
from app.agents.metadata_agent import generate_project_metadata
# from app.agents.export_agent import export_markdown  # COMMENTED: No longer using MinIO
# from app.agents.tools.db_tools import persist_artifact  # DEPRECATED: MongoDB async
from app.core.events import publish
from app.repositories import runs_repo  # MongoDB version


# ------------------------------------------------------------
# Helper: init state (utilise-le dans run_blueprint_pipeline)
# ------------------------------------------------------------
def make_initial_state(project_id: UUID, run_id: UUID, idea: str) -> BlueprintState:
    state: BlueprintState = {
        "project_id": project_id,
        "run_id": run_id,
        "idea": idea,

        # Project metadata (will be generated by metadata agent)
        "project_name": None,
        "project_description": None,

        # init
        "problem_definition": None,
        "functional_requirements": None,
        "non_functional_requirements": None,
        "architecture": None,
        "uml_sequence": None,
        "sprint_planning": None,
        
        # Contenu texte pour frontend (pas de MinIO)
        "requirements_content": None,
        "diagrams_content": None,
        "diagrams_json_content": None,
        "planner_content": None,
        "export_content": None,
        
        # MinIO URIs (COMMENTED - not used anymore)
        # "requirements_uri": None,
        # "diagrams_uri": None,
        # "diagrams_json_uri": None,
        # "planner_uri": None,
        # "plan_uri": None,
        # "result_uri": None,
        
        "blueprint_markdown": None,
    }
    return state


# ------------------------------------------------------------
# Node 0: Metadata (generates project name and description)
# ------------------------------------------------------------
async def node_metadata(state: BlueprintState) -> BlueprintState:
    """
    First node: analyzes the idea and generates project metadata.
    Updates the project immediately with the generated name/description.
    """
    idea = state["idea"]
    run_id = state["run_id"]
    project_id = state["project_id"]

    publish(f"run:{run_id}", "Running: MetadataAgent")

    try:
        # 1) LLM - Generate project metadata
        metadata = await generate_project_metadata(idea)
        
        # 2) Update state
        state["project_name"] = metadata["name"]
        state["project_description"] = metadata["description"]

        # 3) Save to MongoDB run state
        state_json = {
            "project_name": state.get("project_name"),
            "project_description": state.get("project_description"),
        }
        await runs_repo.update_run_state(run_id, state_json)

        # 4) Update the project document immediately
        from app.services.project_service import update_project_metadata
        await update_project_metadata(
            project_id=project_id,
            name=metadata["name"],
            description=metadata["description"]
        )

        # 5) Publish notification
        publish(f"run:{run_id}", f"PROJECT_NAME:{metadata['name']}")
        
        print(f"[METADATA_NODE] Generated: name='{metadata['name']}', desc='{metadata['description']}'")
        
    except Exception as e:
        print(f"[METADATA_NODE] Error: {e}. Using fallback.")
        # Fallback: use idea as name/description
        fallback_name = idea[:60].strip() if len(idea) <= 60 else idea[:57].strip() + "..."
        state["project_name"] = fallback_name
        state["project_description"] = idea[:200].strip() if len(idea) <= 200 else idea[:197].strip() + "..."

    return state


# ------------------------------------------------------------
# Node 1: Requirements
# ------------------------------------------------------------
async def node_requirements(state: BlueprintState) -> BlueprintState:
    idea = state["idea"]
    run_id = state["run_id"]
    project_id = state["project_id"]

    publish(f"run:{run_id}", "Running: RequirementsAgent")

    # 1) LLM - G√©n√®re le contenu requirements
    requirements_md = await generate_requirements(idea)

    # 2) Export (MinIO/S3) - COMMENTED: stockage direct dans state
    # uri = await export_markdown(
    #     project_id=project_id,
    #     content=requirements_md,
    # )

    # 3) Persist DB - COMMENTED: optionnel, on peut garder juste en m√©moire
    # persist_artifact(
    #     session=session,
    #     project_id=project_id,
    #     kind="requirements",
    #     content=requirements_md,
    #     storage_uri=None,
    # )

    # 4) Update state - Stockage direct du texte
    state["problem_definition"] = requirements_md
    state["functional_requirements"] = requirements_md
    state["requirements_content"] = requirements_md  # üÜï Pour le frontend

    # 5) Sauvegarder le state complet en JSON dans la DB (MongoDB async)
    state_json = {
        "requirements_content": state.get("requirements_content"),
        "diagrams_content": state.get("diagrams_content"),
        "diagrams_json_content": state.get("diagrams_json_content"),
        "planner_content": state.get("planner_content"),
        "export_content": state.get("export_content"),
        "blueprint_markdown": state.get("blueprint_markdown"),
    }
    await runs_repo.update_run_state(run_id, state_json)

    return state


# ------------------------------------------------------------
# Node 2: Diagrams
# ------------------------------------------------------------
async def node_diagrams(state: BlueprintState) -> BlueprintState:
    idea = state["idea"]
    run_id = state["run_id"]
    project_id = state["project_id"]

    publish(f"run:{run_id}", "Running: DiagramAgent")

    # 1) LLM - G√©n√®re les diagrammes JSON React Flow
    diagrams_json_str = await generate_diagrams(idea)

    # 2a) Export JSON pour le frontend - COMMENTED: stockage direct
    # from app.agents.tools.storage_tools import put_json
    # json_uri = await put_json(
    #     project_id=project_id,
    #     content=diagrams_json_str,
    #     filename="diagrams.json",
    # )

    # 2b) Markdown pour la doc (description textuelle)
    diagrams_md = f"""# System Diagrams

React Flow diagrams are available in JSON format.
JSON contains 4 diagram types: Class, Sequence, Activity, Use Case.

These diagrams can be rendered directly in the frontend using React Flow.

## Available Diagrams:
- Class Diagram: Object-oriented structure
- Sequence Diagram: Interaction flow
- Activity Diagram: Process flow
- Use Case Diagram: User interactions

"""
    
    # 2c) Export Markdown - COMMENTED: stockage direct
    # uri = await export_markdown(
    #     project_id=project_id,
    #     content=diagrams_md,
    # )

    # 3) Persist DB - COMMENTED: optionnel
    # persist_artifact(
    #     session=session,
    #     project_id=project_id,
    #     kind="diagrams",
    #     content=diagrams_md,
    #     storage_uri=None,
    # )
    # persist_artifact(
    #     session=session,
    #     project_id=project_id,
    #     kind="diagrams_json",
    #     content=diagrams_json_str,
    #     storage_uri=None,
    # )

    # 4) Update state - Stockage direct du texte
    state["architecture"] = diagrams_md
    state["uml_sequence"] = diagrams_md
    state["diagrams_content"] = diagrams_md  # üÜï Markdown pour le frontend
    state["diagrams_json_content"] = diagrams_json_str  # üÜï JSON React Flow

    # 5) Sauvegarder le state complet en JSON dans la DB (MongoDB async)
    state_json = {
        "requirements_content": state.get("requirements_content"),
        "diagrams_content": state.get("diagrams_content"),
        "diagrams_json_content": state.get("diagrams_json_content"),
        "planner_content": state.get("planner_content"),
        "export_content": state.get("export_content"),
        "blueprint_markdown": state.get("blueprint_markdown"),
    }
    await runs_repo.update_run_state(run_id, state_json)

    return state


# ------------------------------------------------------------
# Node 3: Planner
# ------------------------------------------------------------
async def node_planner(state: BlueprintState) -> BlueprintState:
    idea = state["idea"]
    run_id = state["run_id"]
    project_id = state["project_id"]

    publish(f"run:{run_id}", "Running: PlannerAgent")

    # 1) LLM - G√©n√®re le plan de projet
    plan_md = await generate_plan(idea)

    # 2) Export (MinIO/S3) - COMMENTED: stockage direct
    # uri = await export_markdown(
    #     project_id=project_id,
    #     content=plan_md,
    # )

    # 3) Persist - COMMENTED: optionnel
    # persist_artifact(
    #     session=session,
    #     project_id=project_id,
    #     kind="plan",
    #     content=plan_md,
    #     storage_uri=None,
    # )

    # 4) Update state - Stockage direct du texte
    state["sprint_planning"] = plan_md
    state["planner_content"] = plan_md  # üÜï Pour le frontend

    # 5) Sauvegarder le state complet en JSON dans la DB (MongoDB async)
    state_json = {
        "requirements_content": state.get("requirements_content"),
        "diagrams_content": state.get("diagrams_content"),
        "diagrams_json_content": state.get("diagrams_json_content"),
        "planner_content": state.get("planner_content"),
        "export_content": state.get("export_content"),
        "blueprint_markdown": state.get("blueprint_markdown"),
    }
    await runs_repo.update_run_state(run_id, state_json)

    return state


# ------------------------------------------------------------
# Node 4: Export / Result URI
# ------------------------------------------------------------
async def node_export(state: BlueprintState) -> BlueprintState:
    run_id = state["run_id"]

    publish(f"run:{run_id}", "Running: ExportAgent")

    # Assemble markdown final pour la documentation compl√®te
    state["blueprint_markdown"] = "\n\n".join(
        filter(
            None,
            [
                state.get("problem_definition"),
                state.get("architecture"),
                state.get("sprint_planning"),
            ],
        )
    )
    
    # Stocke aussi le contenu final dans export_content
    state["export_content"] = state["blueprint_markdown"]

    # Result URIs - COMMENTED: plus besoin de MinIO
    # state["result_uri"] = (
    #     state.get("plan_uri")
    #     or state.get("requirements_uri")
    #     or state.get("diagrams_uri")
    # )

    # Sauvegarder le state final complet en JSON dans la DB (MongoDB async)
    state_json = {
        "requirements_content": state.get("requirements_content"),
        "diagrams_content": state.get("diagrams_content"),
        "diagrams_json_content": state.get("diagrams_json_content"),
        "planner_content": state.get("planner_content"),
        "export_content": state.get("export_content"),
        "blueprint_markdown": state.get("blueprint_markdown"),
    }
    await runs_repo.update_run_state(run_id, state_json)

    publish(f"run:{run_id}", "DONE: All content stored in state")

    return state
