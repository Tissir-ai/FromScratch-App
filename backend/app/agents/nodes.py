from __future__ import annotations

from typing import cast
import json
from uuid import UUID

from app.agents.state import BlueprintState
from app.agents.requirements_agent import generate_requirements
from app.agents.diagram_agent import generate_diagrams
from app.agents.planner_agent import generate_plan_json
from app.agents.export_agent import generate_export_json
from app.agents.metadata_agent import generate_project_metadata
# from app.agents.export_agent import export_markdown  # COMMENTED: No longer using MinIO
# from app.agents.tools.db_tools import persist_artifact  # DEPRECATED: MongoDB async
from app.core.events import publish
from app.repositories import runs_repo  # MongoDB version


# ------------------------------------------------------------
# Helper: init state (utilise-le dans run_blueprint_pipeline)
# ------------------------------------------------------------
def make_initial_state(project_id: str, run_id: UUID, idea: str) -> BlueprintState:
    state: BlueprintState = {
        "project_id": project_id,
        "run_id": run_id,
        "idea": idea,

        # Project metadata (will be generated by metadata agent)
        "project_name": None,
        "project_description": None,

        # init
        "problem_definition": None,
        "functional_requirements": None,
        "non_functional_requirements": None,
        "architecture": None,
        "uml_sequence": None,
        "sprint_planning": None,
        
        # Contenu texte pour frontend (pas de MinIO)
        "requirements_content": None,
        "diagrams_content": None,
        "diagrams_json_content": None,
        "planner_json_content": None,
        "export_content": None,
        "export_json_content": None,
        
        # MinIO URIs (COMMENTED - not used anymore)
        # "requirements_uri": None,
        # "diagrams_uri": None,
        # "diagrams_json_uri": None,
        # "planner_uri": None,
        # "plan_uri": None,
        # "result_uri": None,
        
        "blueprint_markdown": None,
    }
    return state


# ------------------------------------------------------------
# Node 0: Metadata (generates project name and description)
# ------------------------------------------------------------
async def node_metadata(state: BlueprintState) -> BlueprintState:
    """
    First node: analyzes the idea and generates project metadata.
    Updates the project immediately with the generated name/description.
    """
    idea = state["idea"]
    run_id = state["run_id"]
    project_id = state["project_id"]

    publish(f"run:{run_id}", "Running: MetadataAgent")

    try:
        # 1) LLM - Generate project metadata
        metadata = await generate_project_metadata(idea)
        
        # 2) Update state
        state["project_name"] = metadata["name"]
        state["project_description"] = metadata["description"]

        # 3) Save to MongoDB run state
        state_json = {
            "project_name": state.get("project_name"),
            "project_description": state.get("project_description"),
        }
        await runs_repo.update_run_state(run_id, state_json)

        # 4) Update the project document immediately
        from app.services.project_service import update_project_metadata
        await update_project_metadata(
            project_id=project_id,
            name=metadata["name"],
            description=metadata["description"]
        )

        # 5) Publish notification
        publish(f"run:{run_id}", f"PROJECT_NAME:{metadata['name']}")
        
        print(f"[METADATA_NODE] Generated: name='{metadata['name']}', desc='{metadata['description']}'")
        
    except Exception as e:
        print(f"[METADATA_NODE] Error: {e}. Using fallback.")
        # Fallback: use idea as name/description
        fallback_name = idea[:60].strip() if len(idea) <= 60 else idea[:57].strip() + "..."
        state["project_name"] = fallback_name
        state["project_description"] = idea[:200].strip() if len(idea) <= 200 else idea[:197].strip() + "..."

    return state


# ------------------------------------------------------------
# Node 1: Requirements
# ------------------------------------------------------------
async def node_requirements(state: BlueprintState) -> BlueprintState:
    idea = state["idea"]
    run_id = state["run_id"]
    project_id = state["project_id"]

    publish(f"run:{run_id}", "Running: RequirementsAgent")

    # 1) LLM - GÃ©nÃ¨re le contenu requirements en JSON
    requirements_json_str = await generate_requirements(idea)

    # 2) Clean JSON if wrapped in markdown code blocks
    cleaned_json = requirements_json_str.strip()
    if cleaned_json.startswith("```"):
        lines = cleaned_json.split("\n")
        if lines[0].startswith("```"):
            lines = lines[1:]
        if lines and lines[-1].strip() == "```":
            lines = lines[:-1]
        cleaned_json = "\n".join(lines).strip()

    # 3) Update state - Stockage du JSON structurÃ©
    state["requirements_content"] = cleaned_json  # Store JSON for persistence
    state["requirements_json_content"] = cleaned_json  # Alias for clarity

    # 4) Sauvegarder le state complet en JSON dans la DB (MongoDB async)
    state_json = {
        "requirements_content": state.get("requirements_content"),
        "diagrams_content": state.get("diagrams_content"),
        "diagrams_json_content": state.get("diagrams_json_content"),
        "planner_json_content": state.get("planner_json_content"),
        "export_content": state.get("export_content"),
        "export_json_content": state.get("export_json_content"),
        "blueprint_markdown": state.get("blueprint_markdown"),
    }
    await runs_repo.update_run_state(run_id, state_json)

    return state


# ------------------------------------------------------------
# Node 2: Diagrams
# ------------------------------------------------------------
async def node_diagrams(state: BlueprintState) -> BlueprintState:
    idea = state["idea"]
    run_id = state["run_id"]
    project_id = state["project_id"]

    publish(f"run:{run_id}", "Running: DiagramAgent")

    # 1) LLM - GÃ©nÃ¨re les diagrammes JSON React Flow
    diagrams_json_str = await generate_diagrams(idea)

    # 2a) Export JSON pour le frontend - COMMENTED: stockage direct
    # from app.agents.tools.storage_tools import put_json
    # json_uri = await put_json(
    #     project_id=project_id,
    #     content=diagrams_json_str,
    #     filename="diagrams.json",
    # )

    # 2b) Markdown pour la doc (description textuelle)
    diagrams_md = f"""# System Diagrams

React Flow diagrams are available in JSON format.
JSON contains 4 diagram types: Class, Sequence, Activity, Use Case.

These diagrams can be rendered directly in the frontend using React Flow.

## Available Diagrams:
- Class Diagram: Object-oriented structure
- Sequence Diagram: Interaction flow
- Activity Diagram: Process flow
- Use Case Diagram: User interactions

"""
    
    # 2c) Export Markdown - COMMENTED: stockage direct
    # uri = await export_markdown(
    #     project_id=project_id,
    #     content=diagrams_md,
    # )

    # 3) Persist DB - COMMENTED: optionnel
    # persist_artifact(
    #     session=session,
    #     project_id=project_id,
    #     kind="diagrams",
    #     content=diagrams_md,
    #     storage_uri=None,
    # )
    # persist_artifact(
    #     session=session,
    #     project_id=project_id,
    #     kind="diagrams_json",
    #     content=diagrams_json_str,
    #     storage_uri=None,
    # )

    # 4) Update state - Stockage direct du texte
    state["architecture"] = diagrams_md
    state["uml_sequence"] = diagrams_md
    state["diagrams_content"] = diagrams_md  # ðŸ†• Markdown pour le frontend
    state["diagrams_json_content"] = diagrams_json_str  # ðŸ†• JSON React Flow

    # 5) Sauvegarder le state complet en JSON dans la DB (MongoDB async)
    state_json = {
        "requirements_content": state.get("requirements_content"),
        "diagrams_content": state.get("diagrams_content"),
        "diagrams_json_content": state.get("diagrams_json_content"),
        "planner_json_content": state.get("planner_json_content"),
        "export_content": state.get("export_content"),
        "export_json_content": state.get("export_json_content"),
        "blueprint_markdown": state.get("blueprint_markdown"),
    }
    await runs_repo.update_run_state(run_id, state_json)

    return state


# ------------------------------------------------------------
# Node 3: Planner
# ------------------------------------------------------------
async def node_planner(state: BlueprintState) -> BlueprintState:
    idea = state["idea"]
    run_id = state["run_id"]
    project_id = state["project_id"]

    publish(f"run:{run_id}", "Running: PlannerAgent")

    # 1) LLM - GÃ©nÃ¨re le plan structurÃ© (JSON uniquement - pas de markdown pour Ã©conomiser tokens)
    plan_json_str = await generate_plan_json(idea)

    # 2) Clean JSON if wrapped in markdown code blocks
    cleaned_json = plan_json_str.strip()
    if cleaned_json.startswith("```"):
        lines = cleaned_json.split("\n")
        if lines[0].startswith("```"):
            lines = lines[1:]
        if lines and lines[-1].strip() == "```":
            lines = lines[:-1]
        cleaned_json = "\n".join(lines).strip()

    # 3) Update state - Stockage JSON uniquement (optimisation tokens)
    state["planner_json_content"] = cleaned_json

    # 4) Sauvegarder le state complet en JSON dans la DB (MongoDB async)
    state_json = {
        "requirements_content": state.get("requirements_content"),
        "diagrams_content": state.get("diagrams_content"),
        "diagrams_json_content": state.get("diagrams_json_content"),
        "planner_json_content": state.get("planner_json_content"),
        "export_content": state.get("export_content"),
        "export_json_content": state.get("export_json_content"),
        "blueprint_markdown": state.get("blueprint_markdown"),
    }
    await runs_repo.update_run_state(run_id, state_json)

    return state


# ------------------------------------------------------------
# Node 4: Export / Result URI
# ------------------------------------------------------------
async def node_export(state: BlueprintState) -> BlueprintState:
    run_id = state["run_id"]
    idea = state["idea"]

    publish(f"run:{run_id}", "Running: ExportAgent")

    # 1) Assemble markdown final pour la documentation complÃ¨te
    state["blueprint_markdown"] = "\n\n".join(
        filter(
            None,
            [
                state.get("problem_definition"),
                state.get("architecture"),
                state.get("sprint_planning"),
            ],
        )
    )
    
    # 2) Stocke aussi le contenu final dans export_content
    state["export_content"] = state["blueprint_markdown"]

    # 3) GÃ©nÃ¨re le JSON structurÃ© pour l'export (document + github_export)
    export_json_str = await generate_export_json(
        idea=idea,
        requirements=state.get("requirements_content") or "",
        diagrams_json=state.get("diagrams_json_content") or "",
        planner_json=state.get("planner_json_content") or "",
    )

    # 4) Clean JSON if wrapped in markdown code blocks
    cleaned_json = export_json_str.strip()
    if cleaned_json.startswith("```"):
        lines = cleaned_json.split("\n")
        if lines[0].startswith("```"):
            lines = lines[1:]
        if lines and lines[-1].strip() == "```":
            lines = lines[:-1]
        cleaned_json = "\n".join(lines).strip()

    state["export_json_content"] = cleaned_json

    # 5) Sauvegarder le state final complet en JSON dans la DB (MongoDB async)
    state_json = {
        "requirements_content": state.get("requirements_content"),
        "diagrams_content": state.get("diagrams_content"),
        "diagrams_json_content": state.get("diagrams_json_content"),
        "planner_json_content": state.get("planner_json_content"),
        "export_content": state.get("export_content"),
        "export_json_content": state.get("export_json_content"),
        "blueprint_markdown": state.get("blueprint_markdown"),
    }
    await runs_repo.update_run_state(run_id, state_json)

    publish(f"run:{run_id}", "DONE: All content stored in state")

    return state


# ------------------------------------------------------------
# Node 5: Persist to Collections
# ------------------------------------------------------------
async def node_persist_to_collections(state: BlueprintState) -> BlueprintState:
    """
    Final node: Persists the generated data from state to the appropriate
    domain collections (diagrams, requirements, project, planners, exports).
    Uses existing service functions.
    """
    from app.services import diagram_service, requirement_service, project_service
    from app.services import planner_service, export_service
    from app.domain.diagram import DiagramStructure
    from app.domain.requirement import RequirementStructure
    from datetime import datetime
    
    run_id = state["run_id"]
    project_id = state["project_id"]

    publish(f"run:{run_id}", "Running: PersistToCollections")
    print(f"[PERSIST_NODE] Starting persist for project_id={project_id}")

    try:
        # -----------------------------------------------------
        # 1) Save Diagrams from diagrams_json_content
        # -----------------------------------------------------
        diagrams_json_str = state.get("diagrams_json_content")
        if diagrams_json_str:
            try:
                diagrams_data = json.loads(diagrams_json_str)
                diagrams_saved = 0
                
                # diagrams_data has keys: class, sequence, activity, usecase
                for diagram_type, diagram_content in diagrams_data.items():
                    if isinstance(diagram_content, dict) and "nodes" in diagram_content:
                        diagram_struct = DiagramStructure(
                            title=diagram_content.get("title", f"{diagram_type.capitalize()} Diagram"),
                            type=diagram_content.get("type", diagram_type),
                            nodes=diagram_content.get("nodes", []),
                            edges=diagram_content.get("edges", []),
                            created_at=datetime.utcnow(),
                            updated_at=datetime.utcnow(),
                        )
                        await diagram_service.create(project_id, diagram_struct)
                        diagrams_saved += 1
                
                print(f"[PERSIST_NODE] Saved {diagrams_saved} diagrams")
            except json.JSONDecodeError as e:
                print(f"[PERSIST_NODE] Failed to parse diagrams JSON: {e}")
            except Exception as e:
                print(f"[PERSIST_NODE] Error saving diagrams: {e}")

        # -----------------------------------------------------
        # 2) Save Requirements from requirements_content
        # -----------------------------------------------------
        # 2) Save Requirements from requirements_content (JSON format)
        # -----------------------------------------------------
        requirements_json_str = state.get("requirements_content")
        if requirements_json_str:
            try:
                # Parse JSON requirements
                requirements_data = json.loads(requirements_json_str)
                requirements_list = requirements_data.get("requirements", [])
                requirements_saved = 0
                
                for req_item in requirements_list:
                    requirement_struct = RequirementStructure(
                        title=req_item.get("title", "Untitled Requirement"),
                        category=req_item.get("category", "other"),
                        description=req_item.get("description"),
                        content=req_item.get("content"),
                        created_at=datetime.utcnow(),
                        updated_at=datetime.utcnow(),
                    )
                    await requirement_service.create(project_id, requirement_struct)
                    requirements_saved += 1
                
                print(f"[PERSIST_NODE] Saved {requirements_saved} requirements")
            except json.JSONDecodeError as e:
                print(f"[PERSIST_NODE] Failed to parse requirements JSON: {e}")
            except Exception as e:
                print(f"[PERSIST_NODE] Error saving requirements: {e}")

        # -----------------------------------------------------
        # 3) Update Project with full_description (formatted blueprint)
        # -----------------------------------------------------
        try:
            # Create a formatted full_description from the generated content
            full_desc_parts = []
            
            # Add requirements summary
            requirements_json_str = state.get("requirements_content")
            if requirements_json_str:
                try:
                    requirements_data = json.loads(requirements_json_str)
                    requirements_list = requirements_data.get("requirements", [])
                    if requirements_list:
                        full_desc_parts.append("## Project Requirements\n")
                        for req in requirements_list[:5]:  # Show first 5 requirements
                            full_desc_parts.append(f"### {req.get('title', 'Untitled')}\n")
                            if req.get('description'):
                                full_desc_parts.append(f"{req.get('description')}\n\n")
                except:
                    pass
            
            # Add planner summary
            planner_json_str = state.get("planner_json_content")
            if planner_json_str:
                try:
                    planner_data = json.loads(planner_json_str)
                    full_desc_parts.append("\n## Project Timeline & Budget\n")
                    if planner_data.get("time_estimates"):
                        time_est = planner_data["time_estimates"]
                        full_desc_parts.append(f"- **Duration:** {time_est.get('total_weeks', 'N/A')} weeks\n")
                    if planner_data.get("cost_estimates"):
                        cost_est = planner_data["cost_estimates"]
                        full_desc_parts.append(f"- **Budget:** ${cost_est.get('total_budget', 'N/A'):,.2f}\n")
                except:
                    pass
            
            # Save formatted full_description
            if full_desc_parts:
                formatted_description = "\n".join(full_desc_parts)
                await project_service.update(project_id, {
                    "full_description": formatted_description,
                    "updated_at": datetime.utcnow(),
                })
                print(f"[PERSIST_NODE] Updated project full_description ({len(formatted_description)} chars)")
        except Exception as e:
            print(f"[PERSIST_NODE] Error updating project full_description: {e}")

        # -----------------------------------------------------
        # 4) Save Planner Data to PlannerDomain
        # -----------------------------------------------------
        planner_json_str = state.get("planner_json_content")
        if planner_json_str:
            try:
                planner_doc = await planner_service.update_from_json(project_id, planner_json_str)
                if planner_doc:
                    print(f"[PERSIST_NODE] Saved planner data with {len(planner_doc.risks or [])} risks and {len(planner_doc.success_criteria or [])} success criteria")
                else:
                    print(f"[PERSIST_NODE] Failed to save planner data")
            except Exception as e:
                print(f"[PERSIST_NODE] Error saving planner: {e}")

        # -----------------------------------------------------
        # 5) Save Export Data to ExportDomain
        # -----------------------------------------------------
        export_json_str = state.get("export_json_content")
        if export_json_str:
            try:
                export_doc = await export_service.update_from_json(project_id, export_json_str)
                if export_doc:
                    print(f"[PERSIST_NODE] Saved export document with {len(export_doc.github_export or [])} GitHub repositories")
                else:
                    print(f"[PERSIST_NODE] Failed to save export data")
            except Exception as e:
                print(f"[PERSIST_NODE] Error saving export: {e}")

        publish(f"run:{run_id}", "PERSIST: Data saved to collections")
        print(f"[PERSIST_NODE] Completed successfully")

    except Exception as e:
        print(f"[PERSIST_NODE] Critical error: {e}")
        publish(f"run:{run_id}", f"PERSIST_ERROR: {str(e)}")

    return state
